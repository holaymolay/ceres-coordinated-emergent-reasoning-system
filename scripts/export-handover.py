#!/usr/bin/env python3
"""Generate handover.md from memory.md.

Usage:
  ./scripts/export-handover.py --memory memory.md --out handover.md
  ./scripts/export-handover.py --watch --interval 2
"""
from __future__ import annotations

import argparse
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Dict, List

SNAPSHOT_HEADER = "## Handover Snapshot"
SUBSECTIONS = [
    "### Current Focus",
    "### Recent Progress",
    "### Next Steps",
    "### Risks / Blockers",
]


def normalize_bullets(lines: List[str]) -> List[str]:
    cleaned: List[str] = []
    for line in lines:
        stripped = line.strip()
        if not stripped:
            continue
        if stripped.startswith("- "):
            cleaned.append(stripped)
        elif stripped.startswith("* "):
            cleaned.append("- " + stripped[2:].strip())
        else:
            cleaned.append("- " + stripped)
    if not cleaned:
        cleaned.append("- ")
    return cleaned


def parse_snapshot(lines: List[str]) -> Dict[str, List[str]]:
    start = None
    for i, line in enumerate(lines):
        if line.strip().startswith(SNAPSHOT_HEADER):
            start = i + 1
            break
    if start is None:
        return {}

    end = len(lines)
    for j in range(start, len(lines)):
        line = lines[j]
        if line.startswith("## ") and not line.startswith("### "):
            end = j
            break

    snapshot_lines = lines[start:end]
    data: Dict[str, List[str]] = {title: [] for title in SUBSECTIONS}
    current = None
    for line in snapshot_lines:
        if line.startswith("### "):
            current = line.strip() if line.strip() in data else None
            continue
        if current is None:
            continue
        data[current].append(line.rstrip("\n"))

    return data


def export_handover(memory_path: Path, out_path: Path) -> None:
    if not memory_path.exists():
        raise SystemExit(f"Memory file not found: {memory_path}")

    lines = memory_path.read_text(encoding="utf-8").splitlines()
    snapshot = parse_snapshot(lines)

    now = datetime.now(timezone.utc).isoformat().replace("+00:00", "Z")
    output: List[str] = [
        "# Handover",
        "Status: Export snapshot from `memory.md`. If conflict, `memory.md` prevails.",
        f"Generated by `scripts/export-handover.py` from `{memory_path}` on {now}.",
        "",
    ]

    for section in SUBSECTIONS:
        title = section.replace("### ", "")
        output.append(f"## {title}")
        output.extend(normalize_bullets(snapshot.get(section, [])))
        output.append("")

    out_path.write_text("\n".join(output).rstrip() + "\n", encoding="utf-8")


def watch(memory_path: Path, out_path: Path, interval: float) -> None:
    last_mtime = None
    while True:
        if memory_path.exists():
            mtime = memory_path.stat().st_mtime
            if last_mtime is None or mtime > last_mtime:
                export_handover(memory_path, out_path)
                last_mtime = mtime
        time.sleep(interval)


def main() -> None:
    parser = argparse.ArgumentParser(description="Export handover.md from memory.md")
    parser.add_argument("--memory", default="memory.md", help="Path to memory ledger")
    parser.add_argument("--out", default="handover.md", help="Output handover path")
    parser.add_argument("--watch", action="store_true", help="Watch memory for changes")
    parser.add_argument(
        "--interval",
        type=float,
        default=2.0,
        help="Polling interval in seconds when --watch is set",
    )
    args = parser.parse_args()

    memory_path = Path(args.memory)
    out_path = Path(args.out)

    if args.watch:
        watch(memory_path, out_path, args.interval)
        return

    export_handover(memory_path, out_path)


if __name__ == "__main__":
    main()
